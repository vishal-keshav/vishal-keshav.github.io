[{"authors":["admin"],"categories":null,"content":"I am a graduate student in the computer science department at UMass Amherst. My research interests lie at the intersection of machine learning, deep learning, and systems for machine learning.\nBefore I was a graduate student, I worked at Samsung Research Institute Bengaluru as a Machine Learning Engineer. I received my bachelorâ€™s degree in Mathematics and Computing from the Indian Institute of Technology, Guwahati.\nNew Post: Navigate to my blog post.\n","date":1584230400,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":1584230400,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"I am a graduate student in the computer science department at UMass Amherst. My research interests lie at the intersection of machine learning, deep learning, and systems for machine learning.","tags":null,"title":"Vishal Keshav","type":"authors"},{"authors":["Vishal Keshav"],"categories":[],"content":"Solve this first Let me start by asking what would be the output for the below python code.\nl = [[]]*2 print(l) for i in range(2): for j in range(3): l[i].append(0) print(l)  If you said the output is\n[[],[]] [[0,0,0],[0,0,0]]  then read on. In this post, I am going pictorially outline how python treats its variables, which will eventually explain the correct output we would get from the above program.\nObjects objects, everywhere! In python, everything is an object (having some attributes and functionality). Even an integer is an object (where the value attribute is the value we assign to an integer). When we declare a variable var1 = 47, we are creating an integer type object somewhere in the memory having a value of 47, and var1 is just pointing to that object. Now, consider another object pointer var2 = [47]. This will create an object of type list somewhere in the memory and var2 will point to that object.\nPictorially, this will look something like this Now let\u0026rsquo;s see what happens when we modify those two variables.\nvar1 = var1+1 var2[0] = var2[0]+1  This modification resulted to var1 = 48 and var2 = [48]. All these are consistent with what we think should happen, but under the hood, this is what happened.\nThe object that var1 was pointing to, got destroyed and a new object was created, whereas var2 object remained as it is, only the object at its index 0 got replaced by another int object. So, what going on?\nTo change or not to change, that is the question It turns out that in python, not all objects have the same characteristics. Some can change (list, sets, dictionary are mutable) and some cannot (int, float, tuple are immutable). The immutability does not allow changing the value attribute of the int object (through re-assignment). Instead, upon re-assignment, the original int object reference count gets decremented and the garbage collector ends up destroying the object. The list object, however, mutates and lets the change happen on its 0th index.\nBack to the point When we declared var = [[]]*2, it ends up creating a mutable list object, and then creates another mutable object (again, of type list), placing it twice at index 0 and index 1 of the first list.\nWe can verify this programatically by printing the identity (sort of memory location) for all the objects.\nprint(id(l)) print(id(l[0])) print(id(l[1]))  On my computer, I got these outputs\n140110921293312 140110922225216 140110922225216  This tells us that we end up creating only two objects of type list.\n for j in range(3): l[i].append(0)  In the above code snippet, the object at location 128 has been referenced twice such that 0 is appended thrice each time. As a result, we get the following output:\n[[0,0,0,0,0,0], [0,0,0,0,0,0]]  So, finally, how would we get the expected output [[0,0,0],[0,0,0]]? We need to declare the list object thrice. Below code snippet achives that.\nl = [[],[]] print(l) for i in range(2): for j in range(3): l[i].append(0) print(l)  Conclusion We saw how python treats its variables and what do the variables mean to python language (they are just pointer to objects). This basic understanding sets us to understand the pass-by-value and pass-by-reference paradigm and how python is different in that respect. In the future article, I will explore more on this topic.\n","date":1584230400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1584230400,"objectID":"74a7308ec1a476d0b12758c444e0d9fb","permalink":"/post/python-variables/","publishdate":"2020-03-15T00:00:00Z","relpermalink":"/post/python-variables/","section":"post","summary":"In this article, I will discuss some of the characteristics of python variables.","tags":["Software Engineering"],"title":"Python is a funny language!","type":"post"},{"authors":["Vishal Keshav"],"categories":null,"content":"","date":1577854800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577854800,"objectID":"72bf2e893347efd3a1bbd270f4b14bc5","permalink":"/publication/curriculum-learning/","publishdate":"2020-01-01T00:00:00-05:00","relpermalink":"/publication/curriculum-learning/","section":"publication","summary":"Self-supervised learning techniques have shown their abilities to learn meaningful feature representation. This is made possible by training a model on pretext tasks that only requires to find correlations between inputs or parts of inputs. However, such pretext tasks need to be carefully hand selected to avoid low level signals that could make those pretext tasks trivial. Moreover, removing those shortcuts often leads to the loss of some semantically valuable information. We show that it directly impacts the speed of learning of the downstream task. In this paper we took inspiration from curriculum learning to progressively remove low level signals and show that it significantly increase the speed of convergence of the downstream task.","tags":[],"title":"Self-supervised visual feature learning with curriculum","type":"publication"},{"authors":["Vishal Keshav"],"categories":null,"content":"","date":1567310400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1567310400,"objectID":"39bca6768c7b1f21ab43bc64a4cbe5b4","permalink":"/publication/patent-dnn-based-imaging/","publishdate":"2019-09-01T00:00:00-04:00","relpermalink":"/publication/patent-dnn-based-imaging/","section":"publication","summary":"Provided is a method of DNN-based image processing by an imaging device. The method comprises obtaining, by the imaging device, at least one input image with a plurality of color channels, simultaneously extracting, by the imaging device, a semantic information from each of the color channels of the at least one input image and a color correlation information from each of the color channels of the at least one input image, and generating, by the imaging device, at least one output image based on the extracted semantic information and the extracted color correlation information.","tags":[],"title":"Patent: DNN based imaging","type":"publication"},{"authors":["Vishal Keshav"],"categories":[],"content":"Introduction Regularization techniques are a widely explored topic in machine learning that is used for improving generalization accuracy or reducing the overfitting of the data in a machine learning model. Regularization strategies involve either imposing a hard (or explicit) constraint or a soft (or implicit) constraints on the parameters of the model. Ridge regularizer (often referred to as $L2$) and Lasso regularizer (often referred to as $L1$) are some of the explicit regularizers that impose a direct constraint on the parameter. For example, $L1$ constraints the parameters in a space such that most of the parameter values equal to zero. Implicit regularization approach imposes a soft constraint on the parameters by modifying the optimization function. A popular approach called dropout is an example of such implicit regularizer that tunes the values of the parameters by the means of optimization function.\nThe goal of this article is neither to list down the regularization techniques commonly used in machine learning nor is to describe when and how the regularizers are being used, but to take a step back and understand the importance of prior (an expression of our belief on the values of the parameters) that is embodied in any regularization approach. Towards this end, we will look into two fundamental approaches of parameter estimation methods namely \u0026ldquo;Maximum Likelihood Estimation (MLE)\u0026rdquo; and \u0026ldquo;Maximum a Posteriori (MAP)\u0026rdquo; and see how the later approach regularizes the model better by using prior knowledge about the estimate. We will start with the first approach, MLE.\nMLE Overfits Any meaningful data has some underlying statistical property. For any data we get, it is reasonable to assume that there exists a data generating distribution that has generated the subset of available data. Our objective is to infer the distribution by analyzing the hidden statistical property in the observed data.\nLet us assume that the available data is given by $D$ where $D$ = $(x_{1},x_{2},\u0026hellip;,x_{n})$ and each $x_{i}$ corresponds to $i^{th}$ data point and $x_{i}$ $\\in$ $\\mathbb{R}^{d}$. Furthermore, we assume that each data point is being generated independently by a common data generating distribution denoted by $P(X/\\theta)$ or in other words, each data point $x_{i}$ is sampled from a random variable $X_{i}$ $\\sim$ $P$.\nWe intend to estimate the true parameter $\\theta$ of the assumed data distribution. MLE approaches this problem by maximizing the likelihood function $P(data/\\theta)$, or more formally $$ \\begin{equation} \\theta_{MLE} = \\operatorname*{arg,max}_\\theta P(X_{1}=x_{1},X_{2}=x_{2},\u0026hellip;,X_{n}=x_{n}/\\theta) \\end{equation} $$\nSince it is assumed that the data distribution are identical and independent, by using the conditional independence rule (conditioned on $\\theta$) on the joint probability distribution (over $X_{i}$), we get $$ \\begin{equation} \\theta_{MLE} = \\operatorname*{arg,max}_\\theta \\prod_{i=1}^{n}P(X_{i}/\\theta) \\end{equation} $$\nTaking a concrete example of data distribution, we can derive the maximum likelihood estimate. Lets suppose that data follows a Gaussian distribution (which is a reasonable assumption for scalar data points), and the parameters we are interested in is the mean (denoted by $\\mu$) where we keep the variance (denoted by $\\sigma^{2}$) a constant, i.e. $X_{i}$ $\\sim$ $\\mathcal{N}(\\mu , \\sigma^{2})$. Here, the only parameter we want to estimate is the $\\theta = \\mu$.\nFollowing the Gaussian density function for the given data distribution and the Independent and identically distributed (IID) assumptions, from previous equation we get $$ \\begin{equation} \\theta_{MLE} = \\operatorname*{arg,max}_\\theta \\left ( \\frac{1}{\\sqrt{2\\pi\\sigma^{{2}}}} \\right ) exp\\left ( -\\frac{1}{2\\sigma^{2}}\\sum_{i=1}^{n}(x_{i} - \\mu)^2 \\right ) \\end{equation} $$\nSince the logarithm is a monotonically increasing function, we can maximize $\\log$ of the right side expression and equivalently get the parameter of interest.\n$$ \\begin{align} \\theta_{MLE} \u0026amp; = \\operatorname*{arg,max}_\\theta \\log P(data/\\theta) \\\\\\\n\u0026amp; = \\operatorname*{arg,max}_\\theta -\\frac{n}{2}\\log(2\\pi\\sigma^2) - \\frac{1}{2\\sigma^2}\\sum_{i=1}^{n}(x_{i} - \\mu) \\end{align} $$\nfetches us $\\mu$ = $\\frac{\\sum_{i=1}^{n}x_{i}}{n}$ which is the sample mean. Here we can see that if the dataset is small, the MLE estimate memorizes both the signal and the noise from the data even if we may have some idea of where the parameter should lie.\nAn apt representation of this is idea is shown in the figure below.\nWhen the number of parameter increases and the number of data point remains small, the MLE estimates a complicated function that more often tries to fit the noise present in the data and diverges from the actual data distribution. In the next section, we will see how the MAP estimate overcome this drawback by introducing something called \u0026ldquo;prior\u0026rdquo;.\nMAP Regularizes Our problem statement remains the same as that of MLE, but our assumptions about the underlying statistical properties of the data is a bit different. We now assume that we have a full knowledge about the joint distribution of data and the underlying data distribution\u0026rsquo;s parameter, as denoted by $P(X_{1}, X_{2},\u0026hellip;,X_{n},\\theta)$. Here, we note that the $\\theta$ is now a random variable. Although $\\theta$ is a random variable now, MAP estimates are the point estimates that evaluate the parameter that maximizes a certain condition, in this case it is the posterior distribution of $\\theta$ given the data. Formally,\n$$ \\begin{align} \\theta_{MAP} \u0026amp; = \\operatorname*{arg,max}_\\theta P(\\theta/X_{1},X_{2},\u0026hellip;,X_{n})\\\\\\\n\u0026amp; = \\operatorname*{arg,max}_\\theta \\frac{P(X_{1}, X_{2},\u0026hellip;,X_{n},\\theta)}{P(X_{1}, X_{2},\u0026hellip;,X_{n})}\\\\\\\n\u0026amp; = \\operatorname*{arg,max}_\\theta P(X_{1}, X_{2},\u0026hellip;,X_{n}/\\theta)*P(\\theta) \\end{align} $$\nusing proportionality and Bayes theorem. Taking log and using IID assumption on right-hand side of the expression, we get $$ \\begin{equation} \\theta_{MAP} = \\operatorname*{arg,max}_\\theta \\sum_{i=1}^{n}\\log P(X_{i} = x_{i}/\\theta) + \\log P(\\theta) \\end{equation} $$\nWe again take a concrete example by assuming a joint distribution of data and parameter. Alternatively, we assume that the conditional data distribution conditioned on parameter $\\mu$ follows $\\mathcal{N}(\\mu, \\sigma^{2})$ where $\\theta = \\mu$, $\\sigma$ is kept as a constant and the parameter $\\mu$ is distributed normally with mean $\\mu^{*}$ and a variance of 1 i.e. $\\mu$ = $\\theta$ $\\sim$ $\\mathcal{N}(\\mu^{*}, 1)$. Under these univariate Gaussian assumptions for data and parameter, we can maximize the logarithm of the posterior to estimate the point estimate for $\\theta$. $$ \\begin{align} \\theta_{MAP} = \\operatorname*{arg,max}_\\theta \u0026amp; \\left ( \\frac{1}{\\sqrt{2\\pi\\sigma^{{2}}}} \\right ) exp\\left ( -\\frac{1}{2\\sigma^{2}}\\sum_{i=1}^{n}(x_{i} - \\mu)^2 \\right ) + \\\\\\ \u0026amp; \\left ( \\frac{1}{\\sqrt{2\\pi}} \\right ) exp\\left ( -\\frac{1}{2}(\\mu - \\mu^{*})^2 \\right ) \\end{align} $$\nDifferentiating the right-hand side and equating it to zero, the expression evaluates to $$ \\begin{equation} \\frac{1}{\\sigma^{2}}\\left ( \\sum_{i=1}^{n}(x_{i}-n\\mu)^{2} \\right ) + (\\mu^{*} - \\mu) = 0 \\end{equation} $$ Rearranging the $\\mu$ on one side, we get $\\mu = \\frac{\\sum_{i=1}^{n}x_{i}}{\\sigma^2 + n} + \\frac{\\sigma^{2}}{\\sigma^{2}+n}\\mu^{*}$ Since, $\\overline{x} = \\frac{\\sum_{i=1}^{n}x_{i}}{n}$ is the sample mean, we can write the above equation as $$ \\begin{equation} \\theta_{MAP} = \\frac{n}{\\sigma^2 + n}\\overline{x} + \\frac{\\sigma^{2}}{\\sigma^{2}+n}\\mu^{*} \\end{equation} $$ From the above expression, we can see that the $\\theta_{MLE}$ is a convex combination of sample mean $\\overline{x}$ and the prior mean $\\mu^{*}$. The prior mean $\\mu^{*}$ reflects our prior belief about where the mean should be before we observe any data. When the number of data points are less, more weightage is given on the prior mean which helps in achieving regularization through reducing the data overfitting. In an extream case where $n \\rightarrow \\infty$, $\\frac{n}{\\sigma^2 + n} \\rightarrow 1$ and $\\frac{\\sigma^{2}}{\\sigma^{2}+n} \\rightarrow 0 $, the parameter estimation is dominated by sample mean (which will reasonably estimate the actual parameter of the data distribution). When the number of data points are sufficient, the parameter estimate is well guided by the observed data, otherwise we partially rely on our prior knowledge of what value a parameter should assume.\nRefer the figure below for an intuitive understanding. Summary In this article, we explored two fundamental parameter estimation algorithm namely Maximum Likelihood Estimation and Maximum a Posteriori. By taking concrete examples of the distribution (along with several reasonable assumptions), we argued that MAP estimates induce regularization through prior over the parameters.\nIn a traditional Bayesian setup, a prior is explicitly modeled, but in a deep learning setting, this may take several forms. Whatever be the case, prior knowledge induces better inductive bias and this can be achieved through designing the architecture, curating of the training data and the choosing a better optimization objective. A more direct approach of imposing the prior for regularizing a model can be seen in the process of distillation. A teacher network is trained without any prior data, and when it is trained, the knowledge (in terms of prior) is distilled in the student network. Formulating a better and more explicit approach to induce prior in deep learning systems is an active area of research which we will explore further in subsequent articles.\n","date":1557878400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557878400,"objectID":"5a3367d62d391224abafb9e8797a3c3e","permalink":"/post/regularization/","publishdate":"2019-05-15T00:00:00Z","relpermalink":"/post/regularization/","section":"post","summary":"In this article, we explore the relationship between regularization and the prior belief from baysian point of view.","tags":["Academic"],"title":"Priors and the relationship with regularization","type":"post"},{"authors":["Vishal Keshav"],"categories":null,"content":"","date":1551416400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1551416400,"objectID":"325eeea0dd16fe578f8bfb473114b11f","permalink":"/publication/illumination-estimation/","publishdate":"2019-03-01T00:00:00-05:00","relpermalink":"/publication/illumination-estimation/","section":"publication","summary":"This paper presents a novel design methodology for architecting a light-weight and faster DNN architecture for vision applications. The effectiveness of the architecture is demonstrated on Color-Constancy use case an inherent block in camera and imaging pipelines. Specifically, we present a multi-branch architecture that disassembles the contextual features and color properties from an image, and later combines them to predict a global property (e.g. Global Illumination). We also propose an implicit regularization technique by designing cross-branch regularization block that enables the network to retain high generalization accuracy. With a conservative use of best computational operators, the proposed architecture achieves state-of-the-art accuracy with 30X lesser model parameters and 70X faster inference time for color constancy. It is also shown that the proposed architecture is generic and achieves similar efficiency in other vision applications such as Low-Light photography.","tags":[],"title":"Decoupling Semantic Context and Color Correlation","type":"publication"},{"authors":null,"categories":null,"content":"","date":1548565200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1548565200,"objectID":"3c776fb1b79e2ceb370378504e71b58d","permalink":"/extras/fast-prototype/","publishdate":"2019-01-27T00:00:00-05:00","relpermalink":"/extras/fast-prototype/","section":"extras","summary":"A framework, built on top of tensorflow, to quickly prototype research ideas.","tags":["Machine Learning"],"title":"Fast Prototype","type":"extras"},{"authors":null,"categories":null,"content":"","date":1538020800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1538020800,"objectID":"fbedc91b97ffb05c058b36901a92f064","permalink":"/extras/interpreter/","publishdate":"2018-09-27T00:00:00-04:00","relpermalink":"/extras/interpreter/","section":"extras","summary":"A simplistic interpreter developed in Prolog-programming language.","tags":["CodeOn"],"title":"Interpreter","type":"extras"},{"authors":null,"categories":null,"content":"","date":1538020800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1538020800,"objectID":"c87165965b22320f7a1542372936cbbb","permalink":"/extras/parallel-matrix-multiplication/","publishdate":"2018-09-27T00:00:00-04:00","relpermalink":"/extras/parallel-matrix-multiplication/","section":"extras","summary":"Optimizing parallelized matrix multiplication by 1300 times (as compared to naive algorithm).","tags":["CodeOn"],"title":"Matrix-matrix multiplication","type":"extras"},{"authors":null,"categories":null,"content":"","date":1538020800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1538020800,"objectID":"7c64106810004a31ceb821a6bcbe01a8","permalink":"/extras/py-game/","publishdate":"2018-09-27T00:00:00-04:00","relpermalink":"/extras/py-game/","section":"extras","summary":"A game developed in python, played by an agent, based on Q-learning algorithm","tags":["Machine Learning"],"title":"Py-Game","type":"extras"},{"authors":null,"categories":null,"content":"","date":1538020800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1538020800,"objectID":"1391b9a5dfef0109adb3617386c9e121","permalink":"/extras/tiny-ml-framework/","publishdate":"2018-09-27T00:00:00-04:00","relpermalink":"/extras/tiny-ml-framework/","section":"extras","summary":"A completely vectorized, fast ML-framework withing 700 lines of code","tags":["Machine Learning"],"title":"Tiny-ml-framework","type":"extras"},{"authors":null,"categories":null,"content":"","date":1538020800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1538020800,"objectID":"609370bc3afb3e875c67720e120e81e0","permalink":"/extras/uva/","publishdate":"2018-09-27T00:00:00-04:00","relpermalink":"/extras/uva/","section":"extras","summary":"Solutions for 300 mind-boggling algorithm and data-structure problems from UVa judging site.","tags":["CodeOn"],"title":"UVa","type":"extras"},{"authors":["Vishal Keshav"],"categories":[],"content":"More is Less: A More Complicated Network with Less Inference Complexity Problem solved: With each convolution layer, reduce the computation of convolution that results in zero activation.   Hints about zero features that may lead to zero activation is given by a parallel light-weight convolution (either spatial or depth wise) activation. LCCL (low cost collaborative layer) are parallel low cost convolutions providing zero outcome hints to main convolution. To increase the sparsity, methods such as using RelU activation and Batch Normalization is explored. Mentions of GEMM and GEMV for theoretical and practical acceleration improvements.    LINK\n  Learning Efficient Convolutional Networks through Network Slimming Problem solved: Reducing the input channels that have near zero activation, by enforcing L1 norm to be zero along with regularization effect. Lesser the input channels, faster the inference.   Input channel are pruned during the training by enforcing L1 norm to become zero. L1 regularization on scaling factor of batch normalization layers per channel does not require any architectural changes. Zero L1 enforcement per channel is achieved by addition of L1 norm of batch in the total cost function which then is needed to be minimized. Drop in the prediction accuracy can be restored by retraining with multi-pass scheme.    LINK\n  Pruning Filters For Efficient Convnets Problem solved: Reduction in number of filters with low L1 norm. These filters are assumed to have insignificant contribution to output channels. With reduced filters, both complexity of computation of convolution at current layer and next layer decreases.   Filters in a given layer of a trained model are compared against each other based on L1 norm, and removed proportionally. Removal of filters is done in a single shot for whole network, after which training can be done to restore the accuracy Pruning filters across multiple layer can be done in either independent or greedy way. Sensitivity of pruning filters in a given layer is measured by the rate at which accuracy decreases with respect to number of pruned filter. Highly sensitive layers are left out for pruning.    LINK\n  Data-Driven Sparse Structure Selection for Deep Neural Networks Problem solved: A systematic approach to prune structures is a deep network including filters or neurons, resnet blocks and grouped convolution (cardinality) is presented. Additional parameters in cost function is enforced to zero in order to realize structure pruning.   A general end-to-end framework for pruning structures at once without the need for retraining. Scaling factors is not needed to be necessarily associated to network weights (so does the gradients), these are generalized parameters and gradients are computed in additions to weight gradients Accelerated Proximal Gradient is adopted for scaling factor training    LINK\n  Pruning Convolutional Neural Networks For Resource Efficient Inference Problem solved: Evaluates/proposes the greedy criterion for pruning feature maps with an objective of minimizing the cost difference before and after pruning along with L1 norm constraints on pruned weights. With FLOPs criteria, it achieves resource efficient inference.   It formalizes the gated pruning (i.e. if this feature channel be pruned or not) based on greedy criteria such as minimized weight, mean, deviation of activation, information gain, first order taylor expansion etc. System has two steps, pruning in which based on criteria, the importance of neurons is evaluated and pruned Training in which it trains the network with constrained cost object in consideration.    LINK\n  CondenseNet: An Efficient DenseNet using Learned Group Convolutions Problem solved: Improves the dense-net by introducing the concept of learned group convolution. Condensing and optimization (both being the part of training phase) helps prune filters per logical groups which gets re-arranged by indexing to formulate normal group convolution. Better design strategy for dense-net is also proposed.   Exponential growth rate of input channel is compensated by using depth wise separable convolution in case of dense net. Condense net improvises this by group convolution that learns the grouping. Method used allows groups to automatically select appropriate channels or not use some at all. Since this architecture follows dense-net, non-used channels will be useful in another layer. Condense stage involves pruning per group by sparsity regularizer and optimization stage (second half of training stage) involves re-arranging and indexing of input filters for group convolution.    LINK\n  DelugeNets: Deep Networks with Efficient and Flexible Cross-layer Information Inflows Problem solved: Effectively propagating cross layers parameters as compared to residual blocks but at the same time being more efficient that dense-nets. Through cross-layer depthwise convolution the efficient information flow is possible whilst providing more flexibility than resnets.   Per block, composite network is used (bottle neck design) having same map dimentions. In one block, inputs from each preceding layers are convolved by point wise convolution channel wise. In other words, for a given channel c, all the filter maps at channel c from preceding layers are segregated and convolved depthwise to get filter map of channel c in the input layer. Same process to all channels. For block transition (where dimention changes), 3X3 strided filters are applied to match the input dimentions. Whole idea is to have cross layer separable convolution to reduce computation complexity.    LINK\n  Deep Pyramidal Residual Networks Problem solved: Through empirical studies, it was found that increase in feature map dimention at residual blocks significantly increase the resnet burden at those layers. Thus, a gradual increase in feature map depth is introduced which increase accuracy.   Pyramidal shape is introduced which gradually increase the filters at every layer. Skip connections are done through zero padding instead of 1X1 convolution. Several pyramidal designs are explored which increase the filters as a function of layer index.    LINK\n  Deep Expander Networks: Efficient Deep Networks from Graph Theory Problem solved: Solves high connectivity (for good representational power by efficient information flow through network) but remaining under a given level of sparsity. This reduces the inference time with similar accuracy levels.   Explores graph theory (expanders graphs), in which layer connections are modelled as several bipartite graphs connected after each other. In each bipartite connections, limits the number of edges but still having all connections globally. For structured sparsity, random expanders and explcit expanders are proposed. Explicit expanders are formulated under XOR operation of some group generators and output vertex set.    LINK\n  Aggregated Residual Transformations for Deep Neural Networks Problem solved: Improves the representational power of network to reduce the number of parameters used. Proposed cardinality as a hyper-parameter along with width and depth of the network which is easy to manage. Aggregation of transformed input with addition to produce output is proposed. Design space for mentioned network has lesser parameters (which is cardinality). Increasing cardinality is more effective than increasing depth or width to gain accuracy.   Homogeneous input transform is proposed for implementation which is followed by aggregation or addition (bottleneck architecture). Conceptual difference as compared to Inception-resnet lies in topology followed by each transformation paths. Its the same in this proposal. Conceptual difference as compared to group convolution lies in the fact that grouping can be done only upto one layer, whereas proposed system goes beyond one layer of transformation path.    LINK\n  DeepRebirth: Accelerating Deep Neural Network Execution on Mobile Devices Problem solved: Inference acceleration by streamline slimming (combining across layer depth) and branch slimming (combining along network width) of tensors and non-tensors. Sparsity of tensors are exploited with less relevant high utilization non-tensors through combination and retraining.   Observation about excessive runtimes of non-tensor units are made and possibility of combining those with tensor nearby tensor units is explored.    LINK\n  Accelerating Convolutional Neural Networks for Continuous Mobile Vision via Cache Reuse Problem solved: Faster inference in continuous image data stream in mobile device is proposed by considering the previous layer image similarity with the current input. The idea has been generalized to reusing the blocks of initial convolution computations. Image similarity is measure block wise such that similar blocks are invariant of translation (diamond search).   For computation overhead, image blocks are compared for similarity. For cache erosion (more relevant in deeper layers) where spatial location of data starts making less sense and cache reuse cannot be determined, reuse is restricted to initial layers. Similar to input raw image, convolution output can be treated as input for next layer are cache reuse by spatially comparing the similarity is possible.    LINK\n  BranchyNet: Fast Inference via Early Exiting from Deep Neural Networks Problem solved: Proposes the usage of branches in deeper network for early stopping and as a way to regularize network. Conventional joint optimization based training is used.   Branches helps in faster inferences where convolution of other branches are dropped. As a bi-product of this architecture, regularization and mitigation of vanishing gradient is achieved. Design space for putting branches at different entry points of main branch is explored. Better caching efficiency on CPU is shown.    LINK\n  Crescendo Net: A Simple Deep Convoltional Neural Network with Ensemble Behavior Problem solved: Basic building block called crescendo blocks are proposed wherein multiple convolution parallel layers with incremental depth enable whole network to act as ensembled network. As a results representational strength increases without using residuals.   The different depths of parallel paths lead to different receptive fields and therefore generate features in different abstract levels. Design space for crescendo blocks are explored for less hyper-parameter tuning. Memory efficient training is proposed where other parallel paths are frozen when training for one path is going on. Like fractals-nets, drop-connects is used (dropping paths) along with dropouts.    LINK\n  BlockDrop: Dynamic Inference Paths in Residual Networks Problem solved: Upon observation that human visual system spend less time on simple object and more on complex lead to a dynamic inferencing system that upon context (complexity of input), drops several convolution operation in between (can be modelled as dropping residual blocks). Policy for dropping residula blocks comes from policy network trained for maximizing accuracy while using minimum inference blocks(reward is formulated in such a way in reinforcement learning). Lesser computation on contextual inputs leads to reduction in inferencing time.   Pretrained resnets are jointly trained with policy network that has to output binary vector representing if blocks needs to be dropped or not based on difficulty of input image. Such policy network implicitly learns the input complexity representation. Drop or not per layer is modelled as K dimentional bernoulli. To train the policy network, expected reward is maximized by expected gradient training procedure. Initial steps use curriculum learning followed by joint tuning of policy network and resnet.    LINK\n  ThiNet: A Filter Level Pruning Method for Deep Neural Network Compression Problem solved: Filters of a given layer is pruned such that output of next to next layer is not being affected. This method differs in the regard that it does not consider immediate layer's channel activation in its optimization problem instead relies of having a network with maximum representation capacity. Doing so leads to smaller network without accuracy loss.   After pruning, fine tuning is done to regain the accuracy. Method is data driven as training example is used to determine the importance of a filter based on changes in next to next layer\u0026rsquo;s output(sampled for different pixel, spatial location). Under optimization problem for next channel\u0026rsquo;s representaion strength, predefine compression rate is encoded which determines how many channels and hence how many previous layer filters has to be pruned.    LINK\n  EraseReLU: A Simple Way to Ease the Training of Deep Convolution Neural Networks Problem solved: Eased the training along with accuracy improvements along lesser amount of computations by observing that network become too non-linearized by stacking up non-linear units. It proposes to proportionally remove relu units from each block of network module.   Going from sigmoid to relu helped a portion of neurons to get non-linearized instead of individual neurons per layer. Still, for such layers, application of relu did not linearize negative units. Removing relu in proportion of number of layers helped to get all neurons linearize for several layers. Removing relu from several spots has lead to increase in representational power of networks with less complexity.    LINK\n  SEP-Nets: Small and Effective Pattern Networks Problem Solved: Observation that binarizing only 3X3 convolution(spatial feature extraction) and not 1X1 convolution (feature transformation) may lead to model compression with similar accuracy but a lower computation. Proposes Patter Residual Block on same concept, from which SEP-Nets module is constructed.   At an equivalent accuracy of MobileNets, model size has been compressed. Binarization can be done from initiation or train-binarize-tune method can be adopted. Binarization of non-transformation convolution helps faster computation at inference time. Instead of concatenation, addition operation is used where 1X1 works as inter residual connection.    LINK\n  Local Binary Convolutional Neural Networks Problem solved: By employing the techniques of local binary convolution (predefined filters) instead of learnable weights, paper proposes to reduce the number of parameters required to convolve. Predefined convolution followed by non-linear activation and the followed by 1X1 learnable convolution composes LBCNN modules.   LBC anchor weights can be stochastically generated with required sparsity. Difference map from LBC is produced by similar convolution but with pre-defined weights. Variable pivot and ordering is hence defined by that. Bitmap from difference map is produced by using non-linearity such as sigmoid. To compose the feature map, normal 1X1 convolution is used.    LINK\n  Towards Accurate Binary Convolutional Neural Network Problem Solved: Unlike other binarization technique which straight forward binarizes weights and activation maps, this paper proposes to approximate the full precision by multiple binary filters or activations. With same accuracy, this technique has shown to be computationally efficient.   Using straight thorough estimator, binary filters can be trained. Further, binary filters(calculated using full precision weight mean and variance) may contain sift operator that can be learned. Binary filter coefficients are computed at every train forward iteration by solving linear regression over actual weights and approximated weights. Whole weight binarization and channel level binarization are suggested methods. Activation in the similar way is binarized using multiple binary activation maps, in order to accelerated bitwise computation on FPGA.    LINK\n  clcNet: Improving the Efficiency of Convolutional Neural Network using Channel Local Convolutions Problem Solved: This paper proposes a structured way of composing group convolution such that full channel receptive field in a given block is 100 percent. This introduces the idea of more generalized channel local convolution and acyclic graph called channel dependency graph that connects output channel to input channel in a convolution block and measure channel receptive field of that convolution block.   Observation such as having full channel receptive field in a convolution block is required to have efficient information flow for better representational power in a CNN. Interlaced group convolution, one of the two building block for cnc net is developed which with group convolution completes a convolution block. Determination of block parameters such as number of groups in IGC and GC is done through minimizing a developed cost function per convolution block remaining under the full channel receptive field constraints.    LINK\n  The Enhanced Hybrid MobileNet Problem solved: With some heuristics, paper managed to improve the baseline mobilenet accuracy. Added a third parameter depth and played around with fractional pooling.   Have formulated the computation and parameters ratio with newly added depth parameter. With heuristics approach, improved the baseline accuracy while maintaining the parameter and computation ratio same.    LINK\n  DropMax: Adaptive Stochastic Softmax Problem Solved: Paper proposes to drop exponential terms from logits randomly so that network becomes an ensemble of exponential number of networks each trained on a different subset of problem. Logit dropout probabilities are learned during training steps.   Each training step is considered to be ensemble of exponential models. Computationally intractable probability calculation during inference is approximated with monte-carlo approximations. Idea is to drop classes which are not being confused much so that sub-problem being solved is smaller.    LINK\n  Improving CNN Performance with Min-Max Objective Problem solved: The activation at each layer is visualized to be an object manifold (or a space whose shape inherently represent something) where each dimension corresponds to objective classes to be learned by the network. A cost is proposed that directly considers activation map in optimization target.   Optimization tends to minimize compactness of each object manifold(feature variation) and maximize margin between different manifolds. Applying cost to arbitrary layer takes care of all the previous layers in network, due to backpropagation. To make gradient computation tractable, kernel trick is used.    LINK\n  Dilated Residual Networks Problem solved: Empirical studies on the effect of output and receptive field leads to the conclusion that use of dilated convolution filters in the later layer in state-of-art networks increase accuracy.   Gridding artifacts due to dilation has been removed by removing max pooling and adding additional layers with decreasing dilation rates and removing residuals in those layers. Architecture for dilated residual network (DRN) is presented based on above consideration and it is shown that increase in accuracy has higher as compared to accuracy that would have resulted by increase in parameter.    LINK\n  Interleaved Group Convolutions for Deep Neural Networks Problem solved: Using two group convolution, an interleaved grouped convolution block is created which proves to be wider that normal convolution. Wider network helped network represent more and had higher accuracy.   Permutations in primary group convolution and secondary convolution each makes block equivalent to normal convolution. Interleaving in secondary group is done such that each group has one filter map from every primary group. After applying pointwise convolution on secondary group, channels are permuted back for input to next interleaved group convolution block. Optimal grouping factor has been derived to maximize width of the block.    LINK\n  Incomplete Dot Products for Dynamic Computation Scaling in Neural Network Inference Problem solved: A tunable is provided to adjust how many filters to be used during inference dynamically based of computation requirements. Filters are arranged from highly important to least important (similar to singular values in SVD). Profiles is presented by a set of coefficients (hinting how may filters to be used in each layer)   Incomplete dot product just does the dot products of filters and input channels as required by the profile. Arrangement of convolution channels and filter from high importance to low importance is possible because of the training procedure followed. All coefficient to one is equivalent to complete dot product.    LINK\n  SwGridNet: A Deep Convolutional Neural Network based on Grid Topology for Image Classification Problem solved: Proposed a grid like structure where output to a unit (convolution) is fed by splitting the input from previous block and through previous dimensionally neighboring unit. Such construction enables architecture to act like ensemble of many models as suggested by other simple architecture such as res-net.   Splitting is followed by convolution at grid level which is followed by concatenation from all the unit and input from previous block. Convolution units in a grid can be constructed by varying depth path(which is output feed to deeper neighbor) Number of output channels from each unit can be different from its neighboring units but total input will be equal to the sum of all outputs from neighboring units.    LINK\n  ShaResNet: reducing residual network parameter number by sharingweights Problem solved: Upon observation that in a group of residual blocks(same stage) with same dimensionality (where no resolution reduction is done), spatial convolution can be shared among those residual blocks. By using a shared filters among all the pointwise convolution (or non spatial convolution) on a given stage among res blocks, computation can be reduced with accuracy loss.   Network is trained normally, end-to-end Gradients are back propagated as usual to pointwise convolution and accumulated for shared weight per stage    LINK\n  Convolutional Networks with Adaptive Computation Graphs Problem solved: Paper proposes a method to adaptively switch off block computation (in res-net setting) and allow flow of data to net layers. This adaptive switching is based on input or context passed as an input. By constraining on number of times a layer should be switched off(enforcement during training step), gating mechanism adapts itself to switch off gates for certain inputs reducing computation complexity. Network is also robust to adversarial attacks.   Unlike highway network which is based on soft thresholding, this is hard thresholding. It focuses on utilizing important parts of computation block which have been made efficient to handle certain input. At training step, cost function constrain on number of times a layer should be executed. Soft decision of gating is used during training.    LINK\n  SkipNet: Learning Dynamic Routing in Convolutional Networks Problem solved: It is observed that a complex example needs few extra layers of computation to get correctly predicted. So for non-complex inputs, some layers can be skipped. Skipping a computation block is done through passing previous layer input to a gate(composed of RNN, shared by each layer) component. Using softmax, gate determines if layer be skipped or not.   Hybrid RL training procedure where supervised training step with softmax gating is used for backpropagation to work. RL is used to minimize the computation reward (less computation is rewarding) along with higher accuracy. LSTM RNN is used and shared among layers to reduce gating overhead.    LINK\n  Papers from 2016 EIE: Efficient Inference Engine on Compressed Deep Neural Network Problem solved: To fit whole network model in cache so that DRAM access is minimized, models are Compressed by involving techniques such as pruning and weight sharing. Once model are in cached, computation requires indirect access to weights(exploit static sparsity) and activations (exploit dynamic sparsity) which costs inefficiency. Thus compressed models are expanded. EIE develops a hardware design that directly works on compressed model using CSC format for inference.   CSC(compressed sparse column) format employees two vectors. First encodes shared weights and second encodes relative distance in cache memory. This design effectively works on fully connected layers. Hardware design includes description of all logical units and queuing/scheduling algorithms.    LINK\n  Deep Networks with Stochastic Depth Problem solved: Reduction is training time while improving the generalization accuracy by randomly shortcutting the inputs to next to next layer using identity function (as used in resnet)   Using bernoulli random variable, dropping the layer reduce the train time. At test time, layers are preserved. So, while training, networks are shallower and at inference, they are deeper. Increase in accuracy (as compared to similar static resnet design) is attributed to ensembling nature of many resnets.    LINK\n  PerforatedCNNs: Acceleration through Elimination of Redundant Convolutions Problem solved: Reduction in convolution computation by extrapolating some elements by nearby values. A perforated mask is created that describes what part needs to be have convolved value and which parts can be extrapolated by nearby value.   Perforation masks are created statically or upon the batch observations through out training. Static masks such as uniformly randomized, grid and pooling structured mask is proposed. Based on training data (statistically), impact mask is proposed that removes least important positions such that extrapolation effects on accuracy for those positions can be minimized. At each iteration, perforation rate at each layer is chosen such that impact on the loss is minimized. This is greedy approach.    LINK\n  Papers from 2015 and older Compressing Neural Networks with the Hashing Trick Problem solved: To reduce the model size, weight sharing techniques is proposed where instead of storing actual weight, hash key is stored and at inference time, hash value is restored from weight array.   Hash trick method is used.    LINK\n Tiled convolutional neural networks Problem solved: An approach is presented where a weight is untied or unshared uptil certain distance of spatial location. This can effectively produce invariance to rotation and scaling   Untying of weights are contrasted with tied weight where same set of parameter extracts features for a pixel location. An untied weight is equivalent to freely choose a different weight for a neighboring pixel. Using a different weight per patch remains valid for certain distance until receptive field for certain feature remains relevant. Unsupervised pre-training is used to initialize the weights before supervised backprop.    LINK\n ","date":1537401600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1515801600,"objectID":"cfd3c4a3bfc915d289c4e0bc1e2407b0","permalink":"/post/review-cv/","publishdate":"2018-09-20T00:00:00Z","relpermalink":"/post/review-cv/","section":"post","summary":"Computer vision has been dominated by deep learning architectures with convolution layers. Although, the accuracy of classification tasks has been improved, improvement in other dimentions such as reduction in floating point operations, reduction in parameters etc. has been widely explored. In this review, we brief on research happening in this space by presenting the recent architectural innovation for computer vision.","tags":["Academic"],"title":"A review of Computer Vision Architecture","type":"post"},{"authors":["Vishal Keshav"],"categories":null,"content":"","date":1535774400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1535774400,"objectID":"5005baa07c273bfd7c78ddb2952f87db","permalink":"/publication/optimizating-wireless-serving/","publishdate":"2018-09-01T00:00:00-04:00","relpermalink":"/publication/optimizating-wireless-serving/","section":"publication","summary":"The main aim of the project is to study and apply Queueing Theory in modelling the wireless network node and create a power consumption function along with user specified constraints. Power consumption function is minimized satisfying the constraint using a numerical optimization technique. Optimised parameters are then tested on performance metrics developed.","tags":[],"title":"Optimisation of power consumption in wireless network","type":"publication"},{"authors":null,"categories":null,"content":"Machine learning has become ubiquitous and is now realized in almost every application. This has burdened the machine learning model developers to make necessary modification in the algorithm to select best available architecture such that performance and power needs can be satisfied post-deployment of the application to smart devices such as smartphones and wearables.\nFor most of the part, a developer tunes the model by changing several hyper-parameters. However, any choice of such hyper-parameters comes either by experience and deep insight, or certain guidelines as provided by the architecture developers (based on ablation studies).\nIn this project, we propose to develop a meta-learning algorithm that takes a specified model architecture and tunes it to match the performance requirement on a particular smart-device. More specifically, we propose to build a policy that iteratively removes weights, channels, and layers in a vision-based model to improve upon execution efficiency while maintaining the prediction accuracy. We show that once the policy is constructed on a particular platform, the domain knowledge can be transferred to construct a policy for a different platform.\n","date":1534636800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1534636800,"objectID":"7e4bb22a954ae63e2e5e259e333419ab","permalink":"/extras/xcelerator/","publishdate":"2018-08-19T00:00:00Z","relpermalink":"/extras/xcelerator/","section":"extras","summary":"Experimenting with RL algorithm for neural architecture search","tags":["Machine-Learning"],"title":"Xcelerator: Neural Architecture Search","type":"extras"},{"authors":["Vishal Keshav"],"categories":null,"content":"","date":1506830400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1506830400,"objectID":"8eb6207b8e6e083594ac9b40f59c141f","permalink":"/publication/patent-contextual-task-scheduling/","publishdate":"2017-10-01T00:00:00-04:00","relpermalink":"/publication/patent-contextual-task-scheduling/","section":"publication","summary":"Embodiments herein provide a method for contextual-based task scheduling in an electronic device includes a multi-core processor. The method includes receiving, by a scheduler, a task from an application, wherein the task is tagged as interactive task. Further, the method includes verifying, by the scheduler, that the task is correctly tagged as interactive task. Further, the method includes determining, by the scheduler, whether an interactive session is triggered by the application. Further, the method includes automatically scheduling, by the scheduler, the task on at least one core of the multi-core processor using a fast resource allocation technique when the interactive session is triggered or using a lazy resource allocation technique when the interactive session is not triggered.","tags":[],"title":"Patent: Contextual task scheduling","type":"publication"},{"authors":["Vishal Keshav"],"categories":null,"content":"","date":1475294400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1475294400,"objectID":"7130c6a33f25bbd10ed7de1eff3d90a7","permalink":"/publication/patent-task-execution/","publishdate":"2016-10-01T00:00:00-04:00","relpermalink":"/publication/patent-task-execution/","section":"publication","summary":"Embodiments herein provide a method for managing execution of tasks by a multi-core processor. The method includes detecting a behavior of a task based on runtime pattern of the task. The method includes calculating a demand for the task based on the detected behavior of the task. Further, the method includes managing the execution of the task on a core of the multi-core processor based on the calculated demand. The proposed method performs calculation task demand based on its past run time and controlling taskâ€™s cluster switching behavior in an heterogeneous system in order to improve upon the power efficiency of the system without making a significant impact on performance.","tags":[],"title":"Patent: Task execution","type":"publication"}]